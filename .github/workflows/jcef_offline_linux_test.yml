name: Build Release Client

on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
      version:
        description: 'Version number'
        required: true
        default: '1.0.0'
      upload_latest:
        description: '是否上传到 latest 目录 (true/false)'
        required: false   # 设为非必须
        default: 'false'  # 提供一个默认值
        type: string

jobs:
  release:
    strategy:
      fail-fast: false
      matrix:
        include:
          # - os: macos-latest
          #   arch: x86_64
          #   file_name: 'latest.dmg'
          #   file_extension: '-x64.dmg'
          #   build_arg: '--mac --x64'
          # - os: windows-latest
          #   file_extension: '.exe'
          #   file_name: 'latest.exe'
          #   build_arg: '--win --x64'
          # - os: macos-latest
          #   arch: arm64
          #   file_name: 'arm64-latest.dmg'
          #   file_extension: '-arm64.dmg'
          #   build_arg: '--mac --arm64'
          - os: ubuntu-latest
            arch: x86_64
            file_name: 'latest.deb'
            file_extension: '-x86_64.deb'
            build_arg: '--linux --x64'
          - os: ubuntu-latest-arm64
            arch: arm64
            file_name: 'arm64-latest.deb'
            file_extension: '-arm64.deb'
            build_arg: '--linux --arm64'

    runs-on: ${{ matrix.os }}

    # 将release_test分支的代码检出（即复制）到 GitHub Actions 的运行环境中。
    steps:
      - name: Check out second repository
        uses: actions/checkout@v2
        with:
          repository: ${{ secrets.REPO_URL }}
          path: ${{ secrets.REPO_PATH }}
          ref: ${{ secrets.JCEF_REPO_BRANCH }}
          token: ${{ secrets.ACCESS_TOKEN }}
          
      # Output basic information
      - name: Print basic information
        run: |
          echo "current version: ${{ github.run_id }}"


       # =================================================================
      # 【第一阶段】准备环境：下载 JBR 并安装 jbr JDK
      # =================================================================
      - name: Setup Custom JBR (for Build and Runtime Image)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Downloading and extracting JBR to be used for compilation and as the runtime image..."
          curl.exe -L -o jbr.tar.gz "https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-windows-x64-b1207.37.tar.gz"
          New-Item -Path "jbr-for-build" -ItemType Directory -Force
          tar.exe -xzf jbr.tar.gz -C jbr-for-build --strip-components=1
          
          # 将 JBR 的路径保存到一个环境变量中，供后续步骤使用
          $jbrPath = Resolve-Path -Path "jbr-for-build"
          echo "JBR_BUILD_PATH=$jbrPath" >> $env:GITHUB_ENV
          Write-Host "JBR for compilation is ready at: $jbrPath"
          
      - name: Setup Custom OpenJDK and Set Unique Environment Variable
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Downloading and extracting custom OpenJDK..."
          
          # 1. 定义下载地址和目标文件名
          $url = "https://download.java.net/java/GA/jdk17.0.2/dfd4a8d0985749f896bed50d7138ee7f/8/GPL/openjdk-17.0.2_windows-x64_bin.zip"
          $outputFile = "openjdk.zip"
          $extractDir = "openjdk-custom"

          # 2. 下载并解压
          curl.exe -L -o $outputFile "$url"
          New-Item -Path $extractDir -ItemType Directory -Force
          7z.exe x $outputFile -o"$extractDir" -y

          # 3. 动态获取解压后的 JDK 主目录路径
          $jdkHome = Get-ChildItem -Path $extractDir | Select-Object -First 1 | ForEach-Object { $_.FullName }
          Write-Host "Resolved OpenJDK home path: $jdkHome"

          # 4. 【已修改】将路径保存到一个唯一的环境变量中，而不是直接设置 JAVA_HOME
          echo "OPENJDK_PATH=$jdkHome" >> $env:GITHUB_ENV
          Write-Host "Custom OpenJDK path saved to OPENJDK_PATH for subsequent steps."


      # =================================================================
      # 【第一阶段】准备环境：将 JBR 设置为默认，并安装好 Temurin
      # =================================================================
      - name: Setup Custom JBR as Default JAVA_HOME 
        if: runner.os == 'macOS'
        run: |
          # 根据 matrix.arch 动态选择要下载的 JBR URL
          if [ "${{ matrix.arch }}" == "arm64" ]; then
            JBR_URL="https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-osx-aarch64-b1207.37.tar.gz"
          else
            JBR_URL="https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-osx-x64-b1207.37.tar.gz"
          fi
          
          echo "Downloading JBR for ${{ matrix.arch }}..."
          curl -L -o jbr.tar.gz "$JBR_URL"
          mkdir -p jbr-default
          tar -xzf jbr.tar.gz -C jbr-default --strip-components=1
          
          # 获取 JBR 的绝对路径并设置为默认的 JAVA_HOME
          JBR_HOME_PATH=$(cd jbr-default/Contents/Home && pwd)
          echo "Setting default JAVA_HOME to JBR: $JBR_HOME_PATH"
          echo "JAVA_HOME=$JBR_HOME_PATH" >> $GITHUB_ENV
          echo "$JBR_HOME_PATH/bin" >> $GITHUB_PATH

      - name: Setup Linux Custom JBR as Default JAVA_HOME
        if: runner.os == 'Linux'
        run: |
          # 根据 matrix.arch 动态选择要下载的 JBR URL
          if [ "${{ matrix.arch }}" == "arm64" ]; then
            echo "arm64"
            JBR_URL="https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-linux-aarch64-b1207.37.tar.gz"
          else
            JBR_URL="https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-linux-x64-b1207.37.tar.gz"
          fi
          
          echo "Downloading JBR for ${{ matrix.arch }}..."
          curl -L -o jbr.tar.gz "$JBR_URL"
          mkdir -p jbr-default
          tar -xzf jbr.tar.gz -C jbr-default --strip-components=1
          
          # 获取 JBR 的绝对路径并设置为默认的 JAVA_HOME
          JBR_HOME_PATH=$(cd jbr-default && pwd)
          echo "Setting default JAVA_HOME to JBR: $JBR_HOME_PATH"
          echo "JAVA_HOME=$JBR_HOME_PATH" >> $GITHUB_ENV
          echo "$JBR_HOME_PATH/bin" >> $GITHUB_PATH     

      # java.security open tls1 Windows
      - name: Enable tls1
        if: ${{ runner.os == 'Windows' }}
        # 在这个步骤中，临时覆盖 JAVA_HOME，让 Maven 使用 JBR
        env:
          JAVA_HOME: ${{ env.JBR_BUILD_PATH }}
        run: |
          # sed -i '' "s/\(^jdk.tls.disabledAlgorithms=\)\(.*\)\( TLSv1, TLSv1.1,\)\(.*\)/\1\2\4/" "${{ env.JAVA_HOME }}/conf/security/java.security"
          $filePath = "${{ env.JAVA_HOME }}\conf\security\java.security"
          $content = Get-Content $filePath -Raw
          $updatedContent = $content -replace '(?s)(jdk.tls.disabledAlgorithms\s*=\s*)(.*?)(\s*TLSv1,\s*TLSv1\.1,)(.*?)(?=[,\r\n])', '$1$2$4'

          $updatedContent | Set-Content $filePath
          Write-Output "Original content:"
          Write-Output $content

          # 打印修改后的内容确认替换是否生效
          Write-Output "Updated content:"
          Write-Output $updatedContent

        shell: pwsh

      # java.security open tls1 macOS
      - name: Enable tls1
        if: ${{ runner.os == 'macOS' }}
        run: |
          sed -i '' "s/\(^jdk.tls.disabledAlgorithms=\)\(.*\)\( TLSv1, TLSv1.1,\)\(.*\)/\1\2\4/" $JAVA_HOME/conf/security/java.security

      # Copy jre Windows
      - name: Copy Jre for Windows
        if: ${{ runner.os == 'Windows' }}
        # 在这个步骤中，临时覆盖 JAVA_HOME，让 Maven 使用 JBR
        env:
          JAVA_HOME: ${{ env.JBR_BUILD_PATH }}
        run: |
          # mkdir -p ${{ secrets.REPO_STATIC_PATH }} 
          # cp -r "${{ env.JAVA_HOME }}" ${{ secrets.REPO_JRE_PATH }}
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/win/Home
          cp -r ${{ env.JAVA_HOME }}/* ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/win/Home
          ls ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/win/Home

      # Copy jre macOS
      - name: Copy Jre for macOS arm64
        if: ${{ runner.os == 'macOS' }}
        run: |
          echo $JAVA_HOME
          mkdir -p ${{ secrets.REPO_STATIC_PATH }} 
          cp -r $JAVA_HOME ${{ secrets.REPO_JRE_PATH }} 
          chmod -R 777 ${{ secrets.REPO_JRE_PATH }}
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/mac
          cp -r $JAVA_HOME ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/mac
          chmod -R 777 ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/mac
          cp -r $JAVA_HOME/../Frameworks ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          rm -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac/Frameworks/cef_server.app
          
      # Copy jre Linux
      - name: Copy Jre for Linux
        if: ${{ runner.os == 'Linux' }}
        run: |
          echo $JAVA_HOME
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/linux/Home
          cp -r ${{ env.JAVA_HOME }}/* ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/linux/Home
          ls ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/linux/Home
          rm -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/linux/Home/legal
          ls ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/linux/Home

      # # Copy jre Linux
      # - name: Copy Jre for Linux
      #   if: ${{ runner.os == 'Linux' }}
      #   run: |
      #     mkdir -p ${{ secrets.REPO_STATIC_PATH }} 
      #     cp -r $JAVA_HOME ${{ secrets.REPO_JRE_PATH }} 
      #     chmod -R 777 ${{ secrets.REPO_JRE_PATH }}

      # # Linux
      # - name: Delete File
      #   if: ${{ runner.os == 'Linux' }}
      #   run: |
      #     cd ${{ secrets.REPO_JRE_PATH }} 
      #     ls -la
      #     rm -rf legal
      #     ls -la

      # 安装Node.js
      - name: Install Node.js
        uses: actions/setup-node@main
        with:
          node-version: '18.17.0'
          cache: 'yarn'
          cache-dependency-path: ${{ secrets.REPO_YARN_PATH }}
            
      # 安装Maven
      # - name: Install Java and Maven
      #   uses: actions/setup-java@main
      #   with:
      #     java-version: '17'
      #     distribution: 'temurin'
      #     cache: 'maven'

        # 打包依赖包
      # - name: Check out first repository
      #   uses: actions/checkout@v2
      #   with:
      #     repository: ${{ secrets.REPO_BASE_URL }}
      #     ref: ${{ secrets.TEST_REPO_BASE_BRANCH }}
      #     path: ${{ secrets.REPO_BASE_PATH }}

      - name: Check out sqlParser repository
        uses: actions/checkout@v2
        with:
          repository: ${{ secrets.SQL_PARSER_BASE_URL }}
          ref: ${{ secrets.SQL_PARSER_REPO_BASE_BRANCH }}
          path: ${{ secrets.SQL_PARSER_REPO_BASE_PATH }}
          token: ${{ secrets.ACCESS_TOKEN }}

      # 设置OSS
      - name: Set up oss utils
        uses: yizhoumo/setup-ossutil@v1
        with:
          endpoint: ${{ secrets.OSS_ENDPOINT }}
          access-key-id: ${{ secrets.OSS_ACCESS_KEY_ID }}
          access-key-secret: ${{ secrets.OSS_ACCESS_KEY_SECRET }}
          ossutil-version: '1.7.16'

      # 打包后端工程
      - name: Build BE Static win
        if: ${{ runner.os == 'Windows' }}
          # 在这个步骤中，临时覆盖 JAVA_HOME，让 Maven 使用 JBR
        env:
          JAVA_HOME: ${{ env.JBR_BUILD_PATH }}
        run: |
          pwd
          mvn -v 
          mvn clean install -U -B '-Dmaven.test.skip=true' -f ${{ secrets.REPO_POM_PATH }}
          # ossutil cp -rf ${{ secrets.REPO_JAR_PATH }} "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # cp ${{ secrets.REPO_JAR_PATH }} ${{ secrets.REPO_STATIC_JAR_PATH }} 
          
      # 打包后端工程
      - name: Build BE Static mac
        if: runner.os != 'Windows'
        run: |
          echo "--- Runner Architecture ---"
          uname -m

          echo "--- Maven (mvn) Script Type ---"
          file $(which mvn)

          echo "--- Java Executable Architecture ---"
          file /home/runner/work/cicd-test/cicd-test/jbr-default/bin/java
          pwd
          mvn -v 
          mvn clean install -U -B '-Dmaven.test.skip=true' -f ${{ secrets.REPO_POM_PATH }}
          # ossutil cp -rf ${{ secrets.REPO_JAR_PATH }} "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # cp ${{ secrets.REPO_JAR_PATH }} ${{ secrets.REPO_STATIC_JAR_PATH }}
          

      # 打包前端资源
      - name: Build FE Static
        if: runner.os != 'Windows'
        shell: bash
        run: |
          pushd ${{ secrets.REPO_FRONT_PATH }}
          yarn
          yarn run build:web:desktop --app_version=${{ github.event.inputs.version }}
          # zip -r dist.zip dist
          tar -a -c -f dist.zip dist
          # ossutil cp -rf dist.zip "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          
          cp -r dist ./static/
          
          popd
          echo "Returned to the original directory. Current path is:"
          pwd
          
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile
          cp ${{ secrets.REPO_FRONT_PATH }}/dist.zip ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile
          
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux

          echo "start build version file"
          sh ${{secrets.JCEF_PROJECT_ROOT}}/generate_metadata.sh  ${{ github.event.inputs.version }}  ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile  https://cdn.chat2db-ai.com/offline/updates
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/version.json   ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux


       # Step specifically for Windows
      - name: Build FE Static (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          pushd ${{ secrets.REPO_FRONT_PATH }}
          yarn
          yarn run build:web:desktop --app_version=${{ github.event.inputs.version }}
          
          # 【已修改】在 Windows 上，使用 7-Zip 创建标准的 zip 文件，避免编码问题
          # 7-Zip is pre-installed on GitHub's Windows runners
          7z a -tzip dist.zip ./dist
          
          # ossutil cp -rf dist.zip "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          cp -r dist ./static/
          popd
          
          echo "Returned to the original directory. Current path is:"
          pwd
          
          # The rest of the script is the same, as the commands are compatible
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile
          cp ${{ secrets.REPO_FRONT_PATH }}/dist.zip ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile
          
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux

          echo "start build version file"
          sh ${{secrets.JCEF_PROJECT_ROOT}}/generate_metadata.sh ${{ github.event.inputs.version }} ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile https://cdn.chat2db-ai.com/offline/updates
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux
    
          
      - name: Import Code-Signing Certificate
        if: ${{ runner.os == 'macOS' }}
        run: |
          echo "${{ secrets.MAC_CERTS }}" | base64 --decode > certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          security create-keychain -p "${{ secrets.MAC_CERTS_PASSWORD }}" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "${{ secrets.MAC_CERTS_PASSWORD }}" "$KEYCHAIN_PATH"
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "${{ secrets.MAC_CERTS_PASSWORD }}" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.MAC_CERTS_PASSWORD }}" "$KEYCHAIN_PATH"
          echo "Certificate and key successfully installed."

      - name: Setup Temurin JDK (for jpackage)
        if: runner.os == 'macOS'
        id: setup_temurin_mac
        uses: actions/setup-java@main
        with:
          java-version: '17'
          distribution: 'temurin'
          java-package: 'jdk'
          architecture: ${{ matrix.arch }}
          
      # =================================================================
      # 【第三阶段】在打包前，将环境切换到 Temurin
      # =================================================================
      - name: Switch to Temurin JDK for Packaging
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "Switching active Java environment to Temurin for jpackage..."
          
          # 从 setup_temurin 步骤的输出中，获取 Temurin JDK 的安装路径
          TEMURIN_PATH="${{ steps.setup_temurin.outputs.jdk-path }}"
          echo "Found Temurin JDK path: $TEMURIN_PATH"
          
          # 覆盖 GITHUB_ENV 和 GITHUB_PATH，让后续步骤使用 Temurin
          echo "JAVA_HOME=$TEMURIN_PATH" >> $GITHUB_ENV
          echo "$TEMURIN_PATH/bin" >> $GITHUB_PATH
          echo "Environment switched. Subsequent steps will use Temurin JDK."    


      - name: package mac arm64
        if: ${{ runner.os == 'macOS' && matrix.arch == 'arm64' }}
        run: |
          sh ${{secrets.JCEF_PROJECT_ROOT}}/package_macos.sh  ${{ github.event.inputs.version }} "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg"
          
      - name: package mac x86_64   
        if: ${{ runner.os == 'macOS' && matrix.arch == 'x86_64' }}
        run: |
          sh ${{secrets.JCEF_PROJECT_ROOT}}/package_macos.sh  ${{ github.event.inputs.version }} ${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg
          
        # 公证&签名 Mac App
      - name: Notarize MacOS x86_64 App
        if: matrix.os == 'macos-latest' && matrix.arch == 'x86_64'
        run: |
          xcrun notarytool store-credentials ${{ secrets.PRODUCT_BASE_NAME }} --apple-id "${{ secrets.MAC_APPLE_ID }}" --password "${{ secrets.MAC_APPLE_PASSWORD }}" --team-id "${{ secrets.MAC_TEAM_ID }}"
          xcrun notarytool submit ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg --keychain-profile ${{ secrets.PRODUCT_BASE_NAME }} --wait --verbose
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/*-x64.dmg "oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/"
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/version.json "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/*.jar "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/*.zip "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          echo "oss successful"
      # 公证&签名 Mac App
      - name: Notarize MacOS ARM App
        if: matrix.os == 'macos-latest' && matrix.arch == 'arm64'
        run: |
          xcrun notarytool store-credentials ${{ secrets.PRODUCT_BASE_NAME }} --apple-id "${{ secrets.MAC_APPLE_ID }}" --password "${{ secrets.MAC_APPLE_PASSWORD }}" --team-id "${{ secrets.MAC_TEAM_ID }}"
          xcrun notarytool submit ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg --keychain-profile ${{ secrets.PRODUCT_BASE_NAME }} --wait --verbose
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/*-arm64.dmg "oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/"
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/version.json "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/*.jar "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/*.zip "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          echo "oss successful"
          
      - name: Upload arm64 DMG to OSS if requested
        # 只有当触发工作流时，传入的 upload_latest 参数值为 'true'，此步骤才会执行
        if: matrix.os == 'macos-latest' && matrix.arch == 'arm64' && github.event.inputs.upload_latest == 'true'
        run: |
          echo "检测到需要上传 arm64 DMG，正在执行上传..."
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg "oss://${{ secrets.BUCKET_NAME }}/offline/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.dmg"


      - name: Upload x64 DMG to OSS if requested
        # 只有当触发工作流时，传入的 upload_latest 参数值为 'true'，此步骤才会执行
        if: matrix.os == 'macos-latest' && matrix.arch == 'x86_64' && github.event.inputs.upload_latest == 'true'
        run: |
          echo "检测到需要上传 arm64 DMG，正在执行上传..."
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg "oss://${{ secrets.BUCKET_NAME }}/offline/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.dmg"
     
          
      # - name: upload jar and web zip to oss 
      #   if: ${{ runner.os == 'Windows' }}
      #   shell: bash 
      #   run: |
      #     ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/version.json "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/*.jar "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/*.zip "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
      #     echo "oss successful"     
      
      - name: upload jar and web zip to oss (using PowerShell and ossutil filter)
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        run: |
          # 1. 定义变量
          $SourceDir = "${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile" # PowerShell也能很好地处理正斜杠
          $DestURL = "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          
          # 2. 上传 version.json
          Write-Host "Uploading version.json..."
          ossutil cp -f "${SourceDir}/version.json" "${DestURL}"
          
          # 3. 【推荐】一次性递归上传整个目录，但只包含 .jar 和 .zip 文件
          #    -r 表示递归, -f 表示强制, --include 是过滤器
          Write-Host "Uploading *.jar and *.zip files..."
          ossutil cp -r -f "${SourceDir}" "${DestURL}" --include "*.jar" --include "*.zip"
          
          Write-Host "oss upload successful"
          
      # # 打包Electron
      # - name: Build/release Electron app
      #   uses: samuelmeuli/action-electron-builder@v1
      #   with:
      #     package_root: ${{ secrets.REPO_FRONT_PATH }}
      #     GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }}
      #     mac_certs: ${{ secrets.MAC_CERTS }}
      #     mac_certs_password: ${{ secrets.MAC_CERTS_PASSWORD }}
      #     skip_build: true
      #     args: >
      #       -c.appId=${{ secrets.APP_ID }} -c.productName="${{ secrets.PRODUCT_NAME }}" -c.win.publisherName="${{ secrets.PUBLISHER_NAME }}" -c.nsis.shortcutName="${{ secrets.PRODUCT_NAME }}" -c.extraMetadata.version=${{ github.event.inputs.version }} ${{ matrix.build_arg }}

      - name: package win x64
        if: ${{ runner.os == 'Windows' }}
        shell: bash 
        env:
          # 在这个步骤中，临时将 JAVA_HOME 设置为 OpenJDK 的路径
          JAVA_HOME: ${{ env.OPENJDK_PATH }}
          PATH: ${{ env.OPENJDK_PATH }}/bin:$PATH
        run: |
          # sh ${{secrets.JCEF_PROJECT_ROOT}}/package_win.sh  ${{ github.event.inputs.version }} "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg"
          sh ${{secrets.JCEF_PROJECT_ROOT}}/package_win.sh  ${{ github.event.inputs.version }}
          # ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/*.exe "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/"
          # echo "oss successful"
    
      # 准备发往OSS的文件
      - name: Prepare upload for OSS
        if: ${{ runner.os == 'Windows' }}
        run: |
          pwd
          mkdir -p  ${{ secrets.REPO_FRONT_PATH }}/release
          cp -r ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${{ secrets.REPO_FRONT_PATH }}/release
          ls ${{ secrets.REPO_FRONT_PATH }}/release 
          cp -r ${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${{ github.workspace }}
      - name: Install WinSCP
        if: ${{ runner.os == 'Windows' }}
        run: |
          choco install winscp

      # 上传文件到OSS准备
      - name: Upload to OSS for windows
        if: matrix.os == 'windows-latest'
        run: |
          # ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/temp/"
          ossutil cp -rf "${{ github.workspace }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/temp/"

      # 上传文件到远程服务器
      - name: Copy files to remote server
        if: ${{ runner.os == 'Windows' }}
        timeout-minutes: 15
        env:
          SCP_PASSWORD: ${{ secrets.WIN_SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.WIN_SERVER_IP }}
          REMOTE_USER: ${{ secrets.WIN_SERVER_USER }}
          REMOTE_PATH: '${{ secrets.REMOTE_SIGN_PATH }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          REMOTE_OSS: ${{ secrets.REMOTE_SIGN_SCRIPT_OSS }}
          HOST_KEY: ${{ secrets.HOST_KEY }}
          FILE_TO_UPLOAD: '${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          REMOTE_SCRIPT_PATH_1: '${{ secrets.REMOTE_SIGN_SCRIPT }} --alg SHA-1 ${{ secrets.REMOTE_SIGN_PATH }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          REMOTE_SCRIPT_PATH_2: '${{ secrets.REMOTE_SIGN_SCRIPT }} --alg SHA-256 ${{ secrets.REMOTE_SIGN_PATH }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          LOCAL_DOWNLOAD_PATH: '${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
        run: |
          winscp.com /log=winscp.log /command `
            "option batch abort" `
            "option confirm off" `
            "open scp://${{ env.REMOTE_USER }}:${{ env.SCP_PASSWORD }}@${{ env.REMOTE_HOST }} -hostkey=*" `
            "call ${{ env.REMOTE_OSS }} oss://${{ secrets.BUCKET_NAME }}/offline/updates/${{ github.event.inputs.version }}/temp/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${env:REMOTE_PATH}" `
            "call ${env:REMOTE_SCRIPT_PATH_1}" `
            "call ${env:REMOTE_SCRIPT_PATH_2}" `
            "call ${{ env.REMOTE_OSS }} ${env:REMOTE_PATH} oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe " `
            "exit"

      # 拉取OSS文件
      - name: Prepare upload for OSS on windows
        if: ${{ runner.os == 'Windows' }}
        run: |
          ossutil cp -rf oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/

      - name: Upload x64 exe to OSS if requested
        # 只有当触发工作流时，传入的 upload_latest 参数值为 'true'，此步骤才会执行
        if: matrix.os == 'windows-latest' && github.event.inputs.upload_latest == 'true'
        run: |
          echo "检测到需要上传 x64 exe，正在执行上传..."
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe "oss://${{ secrets.BUCKET_NAME }}/offline/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.exe"

       # Install jre Linux x64
      - name: Install Jre for Linux x64
        if: ${{ runner.os == 'Linux' && matrix.arch == 'x86_64' }}
        uses: actions/setup-java@main
        with:
          java-version: '17'
          distribution: 'temurin'
          java-package: 'jre'

      # Install jre Linux arm64
      - name: Install Jre for Linux arm
        if: ${{ runner.os == 'Linux' && matrix.arch == 'arm64' }}
        uses: actions/setup-java@main
        with:
          java-version: '17'
          distribution: 'temurin'
          java-package: 'jre'
          architecture: 'aarch64'

      - name: package linux arm64
        if: ${{ runner.os == 'Linux' && matrix.arch == 'arm64' }}
        run: |
          /bin/bash ${{secrets.JCEF_PROJECT_ROOT}}/package_linux.sh  ${{ github.event.inputs.version }} "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb"
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/*.deb "oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/"
         
      - name: package linux x86_64   
        if: ${{ runner.os == 'Linux' && matrix.arch == 'x86_64' }}
        run: |
          /bin/bash ${{secrets.JCEF_PROJECT_ROOT}}/package_linux.sh  ${{ github.event.inputs.version }} ${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.deb
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/*.deb "oss://${{ secrets.BUCKET_NAME }}/offline/${{ github.event.inputs.version }}/"
      
          
      # # 修改windows加签后的yml文件
      # - name: Calculate file hash
      #   if: ${{ runner.os == 'Windows' }}
      #   id: hash
      #   run: |
      #     # Step 1: Get the SHA512 hash of the file using CertUtil
      #     $hashOutput = Certutil -hashfile "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" SHA512
      #     Write-Output "CertUtil Output: $hashOutput"

      #     # Extract the hash value (second line of the output)
      #     $hashValue = $hashOutput[1].Trim() -replace ' ', ''

      #     # Step 2: Convert hex string to bytes and then to Base64
      #     $hashBytes = [byte[]]::new($hashValue.Length / 2)
      #     for ($i = 0; $i -lt $hashValue.Length; $i += 2) {
      #       $hashBytes[$i / 2] = [Convert]::ToByte($hashValue.Substring($i, 2), 16)
      #     }
      #     $base64 = [Convert]::ToBase64String($hashBytes)
      #     Write-Output "Base64 Encoded Hash: $base64"

      #     # Set the output variable
      #     echo "::set-output name=sha512_base64::$base64"

      # # 安装yq解析yml
      # - name: Install powershell-yaml module
      #   if: ${{ runner.os == 'Windows' }}
      #   run: |
      #     # Set the execution policy to bypass the prompt about installation from untrusted sources
      #     Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
      #     # Install the powershell-yaml module
      #     Install-Module -Name powershell-yaml -Force -SkipPublisherCheck
      #   shell: powershell

      # - name: Extract, replace, and print hash value
      #   if: ${{ runner.os == 'Windows' }}
      #   continue-on-error: false
      #   run: |
      #     # 引入 powershell-yaml 模块
      #     Import-Module powershell-yaml

      #     # 读取 YAML 文件
      #     $yamlContent = Get-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml -Raw | ConvertFrom-Yaml

      #     # Extract and print the old hash value
      #     Write-Output "Old Hash: $($yamlContent.sha512)"

      #     # 修改 sha512 值
      #     # $yamlContent.sha512 = '${{ steps.hash.outputs.sha512_base64 }}'

      #     # 可选：如果有嵌套的结构，如 files 数组
      #     # $yamlContent.files[0].sha512 = '${{ steps.hash.outputs.sha512_base64 }}'
      #     # 替换哈希值
      #     $newHash = '${{ steps.hash.outputs.sha512_base64 }}'
      #     $content = Get-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml -Raw
      #     $content = $content -replace '(sha512: ).*', "sha512: $newHash"

      #     # 打印新的 sha512 值以确认
      #     Write-Output "New Hash: $newHash"

      #     # 比较旧值和新值
      #     if ($oldHash -eq $newHash) {
      #         Write-Error "❌ Old Hash ($oldHash) and New Hash ($newHash) do not match."
      #         exit 1  # 标记当前步骤失败
      #     } else {
      #         Write-Output "✅ Old Hash and New Hash match. Proceeding with update..."
      #     }

      #     # 将更改写回 YAML 文件
      #     Set-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml -Value $content
      #     # $yamlContent | ConvertTo-Yaml | Set-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml
      #   shell: powershell
      #   env:
      #     new_hash: ${{ steps.hash.outputs.sha512_base64 }}

      # # 上传到OSS
      # - name: Upload to OSS for Mac
      #   if: matrix.os == 'macos-latest' && matrix.arch == 'x86_64'
      #   run: |
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.zip" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/x64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.zip.blockmap" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/x64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-mac.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/x64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.dmg"

      # - name: Upload to OSS for Mac arm64
      #   if: matrix.os == 'macos-latest' && matrix.arch == 'arm64'
      #   run: |
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.zip" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/arm64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.zip.blockmap" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/arm64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-mac.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/arm64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.dmg"

      # - name: Upload to OSS for windows
      #   if: matrix.os == 'windows-latest'
      #   run: |
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/windows/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/latest/windows/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.exe"

      # - name: Upload to OSS for linux x86_64
      #   if: matrix.os == 'ubuntu-latest' && matrix.arch == 'x86_64'
      #   run: |
      #     ls -la ${{ secrets.REPO_FRONT_PATH }}/release/
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-linux.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/"

      # - name: Upload to OSS for linux arm64
      #   if: matrix.os == 'ubuntu-latest' && matrix.arch == 'arm64'
      #   run: |
      #     ls -la ${{ secrets.REPO_FRONT_PATH }}/release/
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-linux-arm64.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/"

      # # 发送到DingTalk
      # - name: Send dingtalk message
      #   uses: ghostoy/dingtalk-action@master
      #   with:
      #     webhook: ${{ secrets.DINGTALK_WEBHOOK }}
      #     msgtype: markdown
      #     content: |
      #       {
      #         "title": "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}-打包完成通知",
      #         "text": "# ${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}-打包完成通知\n ###  任务id：[${{ github.event.inputs.version }}](https://github.com/juliet0416/cicd-test/actions/runs/${{ github.run_id }})\n ### 下载地址：${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}"
      #       }

      # # 发送到飞书
      # - name: Send feishu message
      #   uses: foxundermoon/feishu-action@v2
      #   if: always()
      #   with:
      #     url: ${{ secrets.FEISHU_WEBHOOK }}
      #     msg_type: post
      #     content: |
      #       post:
      #         zh_cn:
      #           title: "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}-打包完成通知"
      #           content:
      #           - - tag: text
      #               text: "任务id："
      #             - tag: a
      #               text: "${{ github.event.inputs.version }}"
      #               href: "https://github.com/juliet0416/cicd-test/actions/runs/${{ github.run_id }}"
      #           - - tag: text
      #               text: "状态: ${{ job.status == 'success' && '✅ 成功' || '❌ 失败' }}"
      #           - - tag: text
      #               text: "下载地址：${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}"

      # - name: Send feishu message
      #   uses: foxundermoon/feishu-action@v2
      #   if: ${{ runner.os == 'Linux' }}
      #   with:
      #     url: ${{ secrets.FEISHU_WEBHOOK }}
      #     msg_type: post
      #     content: |
      #       post:
      #         zh_cn:
      #           title: "${{ secrets.PRODUCT_APP_NAME }} ${{ github.event.inputs.version }} ${{ runner.os }} ${{ matrix.arch }} 打包完成通知"
      #           content:
      #           - - tag: text
      #               text: "任务ID: "
      #             - tag: a
      #               text: "${{ github.run_id }}"
      #               href: "https://github.com/juliet0416/cicd-test/actions/runs/${{ github.run_id }}"
      #           - - tag: text
      #               text: "下载地址: ${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-${{ matrix.arch }}.deb"
      #           - - tag: text
      #               text: "下载地址: ${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-${{ matrix.arch }}.rpm"
      #           - - tag: text
      #               text: "下载地址: ${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-${{ matrix.arch }}.AppImage"
