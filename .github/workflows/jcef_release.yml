name: Build Release Client

on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
      version:
        description: 'Version number'
        required: true
        default: '1.0.0'

jobs:
  release:
    strategy:
      fail-fast: false
      matrix:
        include:
          # - os: macos-latest
          #   arch: x86_64
          #   file_name: 'latest.dmg'
          #   file_extension: '-x64.dmg'
          #   build_arg: '--mac --x64'
          # - os: windows-latest
            # file_extension: '.exe'
            # file_name: 'latest.exe'
            # build_arg: '--win --x64'
          - os: macos-latest
            arch: arm64
            file_name: 'arm64-latest.dmg'
            file_extension: '-arm64.dmg'
            build_arg: '--mac --arm64'
          # - os: ubuntu-latest
          #   arch: x86_64
          #   file_name: 'latest.AppImage'
          #   file_extension: '-x86_64.AppImage'
          #   build_arg: '--linux --x64'
          # - os: ubuntu-latest
          #   arch: arm64
          #   file_name: 'arm64-latest.AppImage'
          #   file_extension: '-arm64.AppImage'
          #   build_arg: '--linux --arm64'

    runs-on: ${{ matrix.os }}

    # 将release_test分支的代码检出（即复制）到 GitHub Actions 的运行环境中。
    steps:
      - name: Check out second repository
        uses: actions/checkout@v2
        with:
          repository: ${{ secrets.REPO_URL }}
          path: ${{ secrets.REPO_PATH }}
          ref: ${{ secrets.JCEF_REPO_BRANCH }}
          token: ${{ secrets.ACCESS_TOKEN }}
          
      # Output basic information
      - name: Print basic information
        run: |
          echo "current version: ${{ github.run_id }}"

      # Install jre Windows
      - name: Install Jre for Windows
        if: ${{ runner.os == 'Windows' }}
        uses: actions/setup-java@main
        with:
          java-version: '17'
          distribution: 'temurin'
          java-package: 'jre'
          
      - name: Setup Custom JBR for Windows
        if: runner.os == 'Windows'
        # 显式指定使用 PowerShell
        shell: pwsh
        run: |
          # --------------------- 准备工作 ---------------------
          Write-Host "Downloading and extracting JBR for Windows..."
          # 下载用户指定的 Windows JBR 版本
          curl.exe -L -o jbr.tar.gz "https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-windows-x64-b1207.37.tar.gz"
          
          # 使用 PowerShell 原生命令创建目录
          New-Item -Path "jbr-17" -ItemType Directory -Force
          
          # GitHub Actions 的 Windows 运行器支持 tar 命令
          tar.exe -xzf jbr.tar.gz -C jbr-17 --strip-components=1
          
          # --------------------- 核心配置步骤 ---------------------
          Write-Host "Configuring environment variables for Windows..."
          
          # 步骤 1: 获取 JBR Home 目录的绝对路径
          # Windows JBR 的结构更简单，解压后就是 Home 目录
          $jbrPath = Resolve-Path -Path "jbr-17"
          Write-Host "Correct JAVA_HOME path will be: $jbrPath"

          # 步骤 2: 设置 JAVA_HOME 环境变量，供后续步骤使用
          echo "JAVA_HOME=$jbrPath" >> $env:GITHUB_ENV

          # 步骤 3: 使用 GITHUB_PATH 将 JBR 的 bin 目录添加到 PATH 最前端
          $jbrBinPath = Join-Path $jbrPath "bin"
          echo "$jbrBinPath" >> $env:GITHUB_PATH
          
          Write-Host "Configuration complete."

      - name: Verify Final Java Configuration for Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "--- Verifying final configuration for Windows ---"
          
          # 1. 检查 JAVA_HOME 环境变量
          Write-Host "JAVA_HOME is: $env:JAVA_HOME"

          # 2. 检查 'java' 命令的指向
          $javaPath = (Get-Command java).Source
          Write-Host "'Get-Command java' points to: $javaPath"
          
          # 3. 检查 Java 版本
          Write-Host "Final 'java -version' output:"
          java -version

          # 4. 最终断言，确保路径正确 (已更新为 Windows 路径格式)
          $expectedPathPart = "jbr-17\bin\java.exe"
          if (-not ($javaPath -like "*$expectedPathPart*")) {
            Write-Error "Failed to set custom JBR path correctly! Expected path to contain '$expectedPathPart' but got '$javaPath'."
            exit 1
          }
          Write-Host "JBR path verification successful."    

      # Install jre MacOS X64
      # - name: Install Jre MacOS X64
        # if: ${{ runner.os == 'macOS' && matrix.arch == 'x86_64' }}
        # uses: actions/setup-java@v2
        # with:
          # java-version: '17'
          # distribution: 'temurin'
          # java-package: 'jre'
          # architecture: 'x64'

      - name: Setup Custom JBR For Mac arm (Final Correct Path)
        if: ${{ runner.os == 'macOS' && matrix.arch == 'arm64' }}
        run: |
          # --------------------- 准备工作 ---------------------
          echo "Downloading and extracting JBR..."
          curl -L -o jbr.tar.gz "https://cache-redirector.jetbrains.com/intellij-jbr/jbr_jcef-17.0.12-osx-aarch64-b1207.37.tar.gz"
          mkdir -p jbr-17
          tar -xzf jbr.tar.gz -C jbr-17 --strip-components=1
          
          # --------------------- 核心配置步骤 (已根据最终路径 jbr-17/Contents/Home 修正) ---------------------
          echo "Configuring environment variables..."
          
          # 步骤 1: 获取 JBR 的 Home 目录的绝对路径 (关键修正)
          # 我们进入 jbr-17/Contents/Home 目录后再获取路径
          JBR_HOME=$(cd jbr-17/Contents/Home && pwd)
          echo "Correct JAVA_HOME path will be: $JBR_HOME"

          # 步骤 2: 设置 JAVA_HOME 环境变量
          echo "JAVA_HOME=$JBR_HOME" >> $GITHUB_ENV

          # 步骤 3: 使用 GITHUB_PATH 将 JBR 的 bin 目录添加到 PATH 最前端
          echo "$JBR_HOME/bin" >> $GITHUB_PATH
          
          echo "Configuration complete."

      - name: Verify Final Java Configuration
        if: ${{ runner.os == 'macOS' && matrix.arch == 'arm64' }}
        run: |
          echo "--- Verifying final configuration ---"
          
          # 1. 检查 JAVA_HOME
          echo "JAVA_HOME is: $JAVA_HOME"

          # 2. 检查 'java' 命令的指向
          WHICH_JAVA=$(which java)
          echo "'which java' points to: $WHICH_JAVA"

          # 3. 检查 Java 版本
          echo "Final 'java -version' output:"
          java -version

          # 4. 最终断言，确保路径正确 (已更新断言路径)
          if [[ ! "$WHICH_JAVA" == *"/jbr-17/Contents/Home/bin/java"* ]]; then
            echo "::error::Failed to set custom JBR path correctly!"
            exit 1
          fi
          
      # Install jre MacOS arm64
      # - name: Install Jre MacOS arm64
      #   if: ${{ runner.os == 'macOS' && matrix.arch == 'arm64' }}
      #   uses: actions/setup-java@main
      #   with:
      #     java-version: '17'
      #     distribution: 'temurin'
      #     java-package: 'jre'
      #     architecture: 'aarch64'

      # Install jre Linux x64
      - name: Install Jre for Linux
        if: ${{ runner.os == 'Linux' && matrix.arch == 'x86_64' }}
        uses: actions/setup-java@main
        with:
          java-version: '17'
          distribution: 'temurin'
          java-package: 'jre'

      # Install jre Linux arm64
      - name: Install Jre for Linux
        if: ${{ runner.os == 'Linux' && matrix.arch == 'arm64' }}
        uses: actions/setup-java@main
        with:
          java-version: '17'
          distribution: 'temurin'
          java-package: 'jre'
          architecture: 'aarch64'

      # java.security open tls1 Windows
      - name: Enable tls1
        if: ${{ runner.os == 'Windows' }}
        run: |
          # sed -i '' "s/\(^jdk.tls.disabledAlgorithms=\)\(.*\)\( TLSv1, TLSv1.1,\)\(.*\)/\1\2\4/" "${{ env.JAVA_HOME }}/conf/security/java.security"
          $filePath = "${{ env.JAVA_HOME }}\conf\security\java.security"
          $content = Get-Content $filePath -Raw
          $updatedContent = $content -replace '(?s)(jdk.tls.disabledAlgorithms\s*=\s*)(.*?)(\s*TLSv1,\s*TLSv1\.1,)(.*?)(?=[,\r\n])', '$1$2$4'

          $updatedContent | Set-Content $filePath
          Write-Output "Original content:"
          Write-Output $content

          # 打印修改后的内容确认替换是否生效
          Write-Output "Updated content:"
          Write-Output $updatedContent

        shell: pwsh

      # java.security open tls1 macOS
      - name: Enable tls1
        if: ${{ runner.os == 'macOS' }}
        run: |
          sed -i '' "s/\(^jdk.tls.disabledAlgorithms=\)\(.*\)\( TLSv1, TLSv1.1,\)\(.*\)/\1\2\4/" $JAVA_HOME/conf/security/java.security

      # Copy jre Windows
      # - name: Copy Jre for Windows
        # if: ${{ runner.os == 'Windows' }}
        # run: |
          # mkdir -p ${{ secrets.REPO_STATIC_PATH }} 
          # cp -r "${{ env.JAVA_HOME }}" ${{ secrets.REPO_JRE_PATH }}
          # mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/win
          # cp -r $JAVA_HOME ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/win

      # Copy jre macOS
      - name: Copy Jre for macOS arm64
        if: ${{ runner.os == 'macOS' && matrix.arch == 'arm64' }}
        run: |
          mkdir -p ${{ secrets.REPO_STATIC_PATH }} 
          cp -r $JAVA_HOME ${{ secrets.REPO_JRE_PATH }} 
          chmod -R 777 ${{ secrets.REPO_JRE_PATH }}
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/mac
          cp -r $JAVA_HOME ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/mac
          chmod -R 777 ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/runtime/mac
          cp -r $JAVA_HOME/../Frameworks ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          

      # Copy jre Linux
      - name: Copy Jre for Linux
        if: ${{ runner.os == 'Linux' }}
        run: |
          mkdir -p ${{ secrets.REPO_STATIC_PATH }} 
          cp -r $JAVA_HOME ${{ secrets.REPO_JRE_PATH }} 
          chmod -R 777 ${{ secrets.REPO_JRE_PATH }}

      # Linux
      - name: Delete File
        if: ${{ runner.os == 'Linux' }}
        run: |
          cd ${{ secrets.REPO_JRE_PATH }} 
          ls -la
          rm -rf legal
          ls -la

      # 安装Node.js
      - name: Install Node.js
        uses: actions/setup-node@main
        with:
          node-version: '18.17.0'
          cache: 'yarn'
          cache-dependency-path: ${{ secrets.REPO_YARN_PATH }}
            
      # 安装Maven
      # - name: Install Java and Maven
      #   uses: actions/setup-java@main
      #   with:
      #     java-version: '17'
      #     distribution: 'temurin'
      #     cache: 'maven'

        # 打包依赖包
      # - name: Check out first repository
      #   uses: actions/checkout@v2
      #   with:
      #     repository: ${{ secrets.REPO_BASE_URL }}
      #     ref: ${{ secrets.TEST_REPO_BASE_BRANCH }}
      #     path: ${{ secrets.REPO_BASE_PATH }}

      - name: Check out sqlParser repository
        uses: actions/checkout@v2
        with:
          repository: ${{ secrets.SQL_PARSER_BASE_URL }}
          ref: ${{ secrets.SQL_PARSER_REPO_BASE_BRANCH }}
          path: ${{ secrets.SQL_PARSER_REPO_BASE_PATH }}
          token: ${{ secrets.ACCESS_TOKEN }}

      # 设置OSS
      - name: Set up oss utils
        uses: yizhoumo/setup-ossutil@v1
        with:
          endpoint: ${{ secrets.OSS_ENDPOINT }}
          access-key-id: ${{ secrets.OSS_ACCESS_KEY_ID }}
          access-key-secret: ${{ secrets.OSS_ACCESS_KEY_SECRET }}
          ossutil-version: '1.7.16'

      # 打包后端工程
      - name: Build BE Static
        run: |
          pwd
          mvn -v 
          mvn clean install -U -B '-Dmaven.test.skip=true' -f ${{ secrets.REPO_POM_PATH }}
          # ossutil cp -rf ${{ secrets.REPO_JAR_PATH }} "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          # cp ${{ secrets.REPO_JAR_PATH }} ${{ secrets.REPO_STATIC_JAR_PATH }}
          

      # 打包前端资源
      - name: Build FE Static
        run: |
          pushd ${{ secrets.REPO_FRONT_PATH }}
          yarn
          yarn run build:web:desktop --app_version=${{ github.event.inputs.version }}
          zip -r dist.zip dist
          ossutil cp -rf dist.zip "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          
          cp -r dist ./static/
          
          popd
          echo "Returned to the original directory. Current path is:"
          pwd
          
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile
          cp ${{ secrets.REPO_FRONT_PATH }}/dist.zip ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile
          
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          mkdir -p ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          cp -r ${{ secrets.REPO_FRONT_PATH }}/dist ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux

          echo "start build version file"
          sh ${{secrets.JCEF_PROJECT_ROOT}}/generate_metadata.sh  ${{ github.event.inputs.version }}  ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile  https://cdn.chat2db-ai.com/download/updates
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/version.json   ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/mac
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/win
          cp ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/sourceFile/local_version.json ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/input/linux
          
          
          
          # sign
          # xcrun notarytool store-credentials ${{ secrets.PRODUCT_BASE_NAME }} --apple-id "${{ secrets.MAC_APPLE_ID }}" --password "${{ secrets.MAC_APPLE_PASSWORD }}" --team-id "${{ secrets.MAC_TEAM_ID }}"
          # xcrun notarytool submit jpackage/output/Chat2DB-Pro-${{ github.event.inputs.version }}-arm64.dmg --keychain-profile ${{ secrets.PRODUCT_BASE_NAME }}

          # ossutil cp -rf jpackage/output/Chat2DB-Pro-${{ github.event.inputs.version }}-arm64.dmg "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf jpackage/input/sourceFile/version.json "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf jpackage/input/sourceFile/*.jar "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          # ossutil cp -rf jpackage/input/sourceFile/*.zip "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          # echo "oss successful"
          
      - name: Import Code-Signing Certificate
        if: ${{ runner.os == 'macOS' }}
        run: |
          echo "${{ secrets.MAC_CERTS }}" | base64 --decode > certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          security create-keychain -p "${{ secrets.MAC_CERTS_PASSWORD }}" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "${{ secrets.MAC_CERTS_PASSWORD }}" "$KEYCHAIN_PATH"
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "${{ secrets.MAC_CERTS_PASSWORD }}" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.MAC_CERTS_PASSWORD }}" "$KEYCHAIN_PATH"
          echo "Certificate and key successfully installed."


      - name: package mac arm64
        if: ${{ runner.os == 'macOS' && matrix.arch == 'arm64' }}
        run: |
          pwd
          sh ${{secrets.JCEF_PROJECT_ROOT}}/package_macos.sh  ${{ github.event.inputs.version }} "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg"
          ossutil cp -rf ${{secrets.JCEF_PROJECT_ROOT}}/jpackage/output/*-arm64.dmg "oss://${{ secrets.BUCKET_NAME }}/download/updates/${{ github.event.inputs.version }}/"
          
      - name: package mac x86_64   
        if: ${{ runner.os == 'macOS' && matrix.arch == 'x86_64' }}
        run: |
          pwd
          sh ${{secrets.JCEF_PROJECT_ROOT}}/package_macos.sh  ${{ github.event.inputs.version }} ${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg
            
          
      # # 打包Electron
      # - name: Build/release Electron app
      #   uses: samuelmeuli/action-electron-builder@v1
      #   with:
      #     package_root: ${{ secrets.REPO_FRONT_PATH }}
      #     GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }}
      #     mac_certs: ${{ secrets.MAC_CERTS }}
      #     mac_certs_password: ${{ secrets.MAC_CERTS_PASSWORD }}
      #     skip_build: true
      #     args: >
      #       -c.appId=${{ secrets.APP_ID }} -c.productName="${{ secrets.PRODUCT_NAME }}" -c.win.publisherName="${{ secrets.PUBLISHER_NAME }}" -c.nsis.shortcutName="${{ secrets.PRODUCT_NAME }}" -c.extraMetadata.version=${{ github.event.inputs.version }} ${{ matrix.build_arg }}

      # # 公证&签名 Mac App
      # - name: Notarize MacOS x86_64 App
      #   if: matrix.os == 'macos-latest' && matrix.arch == 'x86_64'
      #   run: |
      #     xcrun notarytool store-credentials ${{ secrets.PRODUCT_BASE_NAME }} --apple-id "${{ secrets.MAC_APPLE_ID }}" --password "${{ secrets.MAC_APPLE_PASSWORD }}" --team-id "${{ secrets.MAC_TEAM_ID }}"
      #     xcrun notarytool submit ${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg --keychain-profile ${{ secrets.PRODUCT_BASE_NAME }}

      # # 公证&签名 Mac App
      # - name: Notarize MacOS ARM App
      #   if: matrix.os == 'macos-latest' && matrix.arch == 'arm64'
      #   run: |
      #     xcrun notarytool store-credentials ${{ secrets.PRODUCT_BASE_NAME }} --apple-id "${{ secrets.MAC_APPLE_ID }}" --password "${{ secrets.MAC_APPLE_PASSWORD }}" --team-id "${{ secrets.MAC_TEAM_ID }}"
      #     xcrun notarytool submit ${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg --keychain-profile ${{ secrets.PRODUCT_BASE_NAME }}

      # 准备发往OSS的文件
      - name: Prepare upload for OSS
        if: ${{ runner.os == 'Windows' }}
        run: |
          pwd
          cp -r ${{ secrets.REPO_FRONT_PATH }}/../chat2db-server/jpackage/output/Chat2DB-Pro-${{ github.event.inputs.version }}.exe ${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe
          ls ${{ secrets.REPO_FRONT_PATH }}/release 
          cp -r ${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${{ github.workspace }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe
      - name: Install WinSCP
        if: ${{ runner.os == 'Windows' }}
        run: |
          choco install winscp

      # 上传文件到OSS准备
      - name: Upload to OSS for windows
        if: matrix.os == 'windows-latest'
        run: |
          # ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/temp/"
          ossutil cp -rf "${{ github.workspace }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/temp/"

      # 上传文件到远程服务器
      - name: Copy files to remote server
        if: ${{ runner.os == 'Windows' }}
        timeout-minutes: 15
        env:
          SCP_PASSWORD: ${{ secrets.WIN_SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.WIN_SERVER_IP }}
          REMOTE_USER: ${{ secrets.WIN_SERVER_USER }}
          REMOTE_PATH: '${{ secrets.REMOTE_SIGN_PATH }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          REMOTE_OSS: ${{ secrets.REMOTE_SIGN_SCRIPT_OSS }}
          HOST_KEY: ${{ secrets.HOST_KEY }}
          FILE_TO_UPLOAD: '${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          REMOTE_SCRIPT_PATH_1: '${{ secrets.REMOTE_SIGN_SCRIPT }} --alg SHA-1 ${{ secrets.REMOTE_SIGN_PATH }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          REMOTE_SCRIPT_PATH_2: '${{ secrets.REMOTE_SIGN_SCRIPT }} --alg SHA-256 ${{ secrets.REMOTE_SIGN_PATH }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
          LOCAL_DOWNLOAD_PATH: '${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe'
        run: |
          winscp.com /log=winscp.log /command `
            "option batch abort" `
            "option confirm off" `
            "open scp://${{ env.REMOTE_USER }}:${{ env.SCP_PASSWORD }}@${{ env.REMOTE_HOST }} -hostkey=*" `
            "call ${{ env.REMOTE_OSS }} oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/temp/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${env:REMOTE_PATH}" `
            "call ${env:REMOTE_SCRIPT_PATH_1}" `
            "call ${env:REMOTE_SCRIPT_PATH_2}" `
            "call ${{ env.REMOTE_OSS }} ${env:REMOTE_PATH} oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe " `
            "exit"

      # 拉取OSS文件
      - name: Prepare upload for OSS on windows
        if: ${{ runner.os == 'Windows' }}
        run: |
          ossutil cp -rf oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe ${{ secrets.REPO_FRONT_PATH }}/release/

      # 修改windows加签后的yml文件
      - name: Calculate file hash
        if: ${{ runner.os == 'Windows' }}
        id: hash
        run: |
          # Step 1: Get the SHA512 hash of the file using CertUtil
          $hashOutput = Certutil -hashfile "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" SHA512
          Write-Output "CertUtil Output: $hashOutput"

          # Extract the hash value (second line of the output)
          $hashValue = $hashOutput[1].Trim() -replace ' ', ''

          # Step 2: Convert hex string to bytes and then to Base64
          $hashBytes = [byte[]]::new($hashValue.Length / 2)
          for ($i = 0; $i -lt $hashValue.Length; $i += 2) {
            $hashBytes[$i / 2] = [Convert]::ToByte($hashValue.Substring($i, 2), 16)
          }
          $base64 = [Convert]::ToBase64String($hashBytes)
          Write-Output "Base64 Encoded Hash: $base64"

          # Set the output variable
          echo "::set-output name=sha512_base64::$base64"

      # 安装yq解析yml
      - name: Install powershell-yaml module
        if: ${{ runner.os == 'Windows' }}
        run: |
          # Set the execution policy to bypass the prompt about installation from untrusted sources
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          # Install the powershell-yaml module
          Install-Module -Name powershell-yaml -Force -SkipPublisherCheck
        shell: powershell

      - name: Extract, replace, and print hash value
        if: ${{ runner.os == 'Windows' }}
        continue-on-error: false
        run: |
          # 引入 powershell-yaml 模块
          Import-Module powershell-yaml

          # 读取 YAML 文件
          $yamlContent = Get-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml -Raw | ConvertFrom-Yaml

          # Extract and print the old hash value
          Write-Output "Old Hash: $($yamlContent.sha512)"

          # 修改 sha512 值
          # $yamlContent.sha512 = '${{ steps.hash.outputs.sha512_base64 }}'

          # 可选：如果有嵌套的结构，如 files 数组
          # $yamlContent.files[0].sha512 = '${{ steps.hash.outputs.sha512_base64 }}'
          # 替换哈希值
          $newHash = '${{ steps.hash.outputs.sha512_base64 }}'
          $content = Get-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml -Raw
          $content = $content -replace '(sha512: ).*', "sha512: $newHash"

          # 打印新的 sha512 值以确认
          Write-Output "New Hash: $newHash"

          # 比较旧值和新值
          if ($oldHash -eq $newHash) {
              Write-Error "❌ Old Hash ($oldHash) and New Hash ($newHash) do not match."
              exit 1  # 标记当前步骤失败
          } else {
              Write-Output "✅ Old Hash and New Hash match. Proceeding with update..."
          }

          # 将更改写回 YAML 文件
          Set-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml -Value $content
          # $yamlContent | ConvertTo-Yaml | Set-Content -Path ${{ secrets.REPO_FRONT_PATH }}/release/latest.yml
        shell: powershell
        env:
          new_hash: ${{ steps.hash.outputs.sha512_base64 }}

      # # 上传到OSS
      # - name: Upload to OSS for Mac
      #   if: matrix.os == 'macos-latest' && matrix.arch == 'x86_64'
      #   run: |
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.zip" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/x64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.zip.blockmap" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/x64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-mac.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/x64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.dmg"

      # - name: Upload to OSS for Mac arm64
      #   if: matrix.os == 'macos-latest' && matrix.arch == 'arm64'
      #   run: |
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.zip" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/arm64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.zip.blockmap" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/arm64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-mac.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/mac/arm64/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.dmg" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.dmg"

      # - name: Upload to OSS for windows
      #   if: matrix.os == 'windows-latest'
      #   run: |
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/windows/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/latest/windows/"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}.exe" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.exe"

      # - name: Upload to OSS for linux x86_64
      #   if: matrix.os == 'ubuntu-latest' && matrix.arch == 'x86_64'
      #   run: |
      #     ls -la ${{ secrets.REPO_FRONT_PATH }}/release/
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.AppImage"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-amd64.deb"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-latest.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-x86_64.rpm"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-linux.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/x86_64/"

      # - name: Upload to OSS for linux arm64
      #   if: matrix.os == 'ubuntu-latest' && matrix.arch == 'arm64'
      #   run: |
      #     ls -la ${{ secrets.REPO_FRONT_PATH }}/release/
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.AppImage"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.AppImage"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.deb"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.deb"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-arm64.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/${{ secrets.PRODUCT_APP_NAME }}-arm64-latest.rpm"
      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-aarch64.rpm"

      #     ossutil cp -rf "${{ secrets.REPO_FRONT_PATH }}/release/latest-linux-arm64.yml" "oss://${{ secrets.BUCKET_NAME }}/download/latest/linux/arm64/"

      # # 发送到DingTalk
      # - name: Send dingtalk message
      #   uses: ghostoy/dingtalk-action@master
      #   with:
      #     webhook: ${{ secrets.DINGTALK_WEBHOOK }}
      #     msgtype: markdown
      #     content: |
      #       {
      #         "title": "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}-打包完成通知",
      #         "text": "# ${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}-打包完成通知\n ###  任务id：[${{ github.event.inputs.version }}](https://github.com/juliet0416/cicd-test/actions/runs/${{ github.run_id }})\n ### 下载地址：${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}"
      #       }

      # # 发送到飞书
      # - name: Send feishu message
      #   uses: foxundermoon/feishu-action@v2
      #   if: always()
      #   with:
      #     url: ${{ secrets.FEISHU_WEBHOOK }}
      #     msg_type: post
      #     content: |
      #       post:
      #         zh_cn:
      #           title: "${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}-打包完成通知"
      #           content:
      #           - - tag: text
      #               text: "任务id："
      #             - tag: a
      #               text: "${{ github.event.inputs.version }}"
      #               href: "https://github.com/juliet0416/cicd-test/actions/runs/${{ github.run_id }}"
      #           - - tag: text
      #               text: "状态: ${{ job.status == 'success' && '✅ 成功' || '❌ 失败' }}"
      #           - - tag: text
      #               text: "下载地址：${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}${{ matrix.file_extension }}"

      # - name: Send feishu message
      #   uses: foxundermoon/feishu-action@v2
      #   if: ${{ runner.os == 'Linux' }}
      #   with:
      #     url: ${{ secrets.FEISHU_WEBHOOK }}
      #     msg_type: post
      #     content: |
      #       post:
      #         zh_cn:
      #           title: "${{ secrets.PRODUCT_APP_NAME }} ${{ github.event.inputs.version }} ${{ runner.os }} ${{ matrix.arch }} 打包完成通知"
      #           content:
      #           - - tag: text
      #               text: "任务ID: "
      #             - tag: a
      #               text: "${{ github.run_id }}"
      #               href: "https://github.com/juliet0416/cicd-test/actions/runs/${{ github.run_id }}"
      #           - - tag: text
      #               text: "下载地址: ${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-${{ matrix.arch }}.deb"
      #           - - tag: text
      #               text: "下载地址: ${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-${{ matrix.arch }}.rpm"
      #           - - tag: text
      #               text: "下载地址: ${{secrets.CDN_URL}}/download/${{ github.event.inputs.version }}/${{ secrets.PRODUCT_APP_NAME }}-${{ github.event.inputs.version }}-${{ matrix.arch }}.AppImage"
